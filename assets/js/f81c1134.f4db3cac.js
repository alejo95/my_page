"use strict";(self.webpackChunkmy_page=self.webpackChunkmy_page||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"vagrant","metadata":{"permalink":"/blog/vagrant","editUrl":"http://iamdevops.site/my_page/edit/main/blog/2025/repository_management/vagrant_blog.md","source":"@site/blog/2025/repository_management/vagrant_blog.md","title":"Aprendiendo iaC con Vagrant","description":"En este corto blog hablare sobre lo bueno y lo malo de Vagran como proveedor iaC(infraestruc como codigo)","date":"2025-06-22T00:00:00.000Z","tags":[{"inline":false,"label":"Vagrant","permalink":"/blog/tags/tags/vagrant"},{"inline":false,"label":"Automation","permalink":"/blog/tags/tags/automation"}],"readingTime":4.32,"hasTruncateMarker":true,"authors":[{"name":"Alejandro Ram\xedrez","title":"Software Engineer | DevOps | Back-end Developer","url":"https://alejo95.github.io/my_page/about_me","description":"Alejandro Ram\xedrez is a back-end developer with a passion for creating efficient and scalable applications. He has a strong background in software development and is always eager to learn new technologies.\\n","social":{"linkedin":"https://www.linkedin.com/in/alejandro-ramirez-95/"},"imageURL":"https://avatars.githubusercontent.com/u/30883786?s=96&v=4","key":"alejandro-ramirez","page":null}],"frontMatter":{"slug":"vagrant","sidebar_position":1,"title":"Aprendiendo iaC con Vagrant","tags":["vagrant","automation"],"authors":"alejandro-ramirez","date":"2025-06-22T00:00:00.000Z"},"unlisted":false,"nextItem":{"title":"Database DevOps con Liquibase","permalink":"/blog/liquibase"}},"content":"\x3c!-- truncate --\x3e\\n\\nEn este corto blog hablare sobre lo bueno y lo malo de Vagran como proveedor **iaC**(infraestruc como codigo)\\npero antes definiremos ques **iaC**\\n\\n## \xbfQues es la infraesctructra como codigo o iaC?\\n\\nLa ***infraestructura como codigo*** o como se conoce con sus siglas en ingles **iaC** es una practica que utiliza archivos de\\nconfiguraci\xf3n para autimatizar procesos que se pueden realizar de forma manual, pero esto en su practica puede traer inconvenientes\\nya que estos procesos tienen a ser repetitivos \ud83d\udd01.\\n\\nLa evoluci\xf3n y la necesidad de atomatizar los procesos de gestion de la infeaestructra llevo ala ceaci\xf3n de este paradicma y al dia\\nde hoy se consolido como una practica fundamneta deltro del moviento DevOps, buscando tratar la infraestructra de manera simila al\\ncodigo, utlizando herramientas como lo es en este caso **Vagrant**.\\n\\n### \xbfQue es vagrant?\\n\\nVagran es una soluci\xf3n creada por HashiCorp, es una heramienta de codigo abierto que facilita la gestion del ciclo de vida\\nde maquinas virtuales, la cual nos permite definir y configurar nuestro entornos de desarollo reproducibles y configurables,\\nutilizando archivos de configuraci\xf3n para especificar desde el sistema operativo, la red, los usiarios, entre otras configuraciones.\\nVagrant esta dise\xf1ado para facilitar el flujo de trabajo de desarollo y pruebas.\\n\\n### \xbfLo Bueno y lo Malo?\\n\\n| Lo bueno                               | Lo Malo                                   |\\n|----------------------------------------|-------------------------------------------|\\n| Muy ligero            | Las configuraciones avanzada depende del proveedor de VM.  |\\n| Facil de modficiar y distribuir  | No esta adapatado para esenario complejos.      |\\n| Facil de integran en entorno DevOps | Mas lentonto que un contenedor.              |\\n| Es de codigo abierto        |   Consume demaciada memoria                          |\\n| Distribuye imagenes limpias con configuraciones completas| Entornos limitados      |\\n\\nYa que tenemos tantas limitaciones dejare algunos de los esearios en que puede ser util vagran ya que esta solucion la podemos\\nimplementar mas facil haciendo uso de herramientas como **docker** y **docker-compose**.\\n\\n    1. Al tener entornos replicables en produci\xf3n\\n    2. Cuando vamos a trabajar con varios sitemas operativos (Implementar laboratorios)\\n    3. En caso de no querer depender de la infraestrucra del host dond estas alojando tu software\\n\\n### \ud83d\ude80 Comandos Clave de Vagrant\\n\\n|Comando|Descripci\xf3n|\\n|---------|---------|\\n|vagrant init|Crea un Vagrantfile b\xe1sico|\\n|vagrant up|Inicia la VM (+ provisionamiento)|\\n|vagrant ssh|Con\xe9ctate a la VM por SSH|\\n|vagrant halt|Apaga la VM|\\n|vagrant destroy|Elimina la VM (\xa1cuidado!)|\\n|vagrant provision|Re-ejecuta el provisionamiento|\\n\\n## \ud83d\udc68\u200d\u2695\ufe0f Laboratorio\\n\\nVamos a iniciar a crear nuestra estructura la cual es la siguiente\\nEsta es una estrucrura que puedes generar con vagrant para que puedas tener\\nmas organizado tu proyecto de vagrant\\n\\n    ```bash title=\\"Bash\\"\\n    vagrant-nginx-lab/\\n    \u251c\u2500\u2500 html\\n    \u2502\xa0\xa0 \u2514\u2500\u2500 index.html\\n    \u251c\u2500\u2500 README.md\\n    \u2514\u2500\u2500 Vagrantfile\\n    ```\\n\\n### \ud83d\udcbb Instalar Vagrant\\n\\nDescargar desde vagrantup.com y ejecutar el .msi\\n\\n### \ud83e\uddea \xbfQu\xe9 contiene este laboratorio?\\n\\n- `Vagrantfile`: define el entorno, el contenedor, el volumen y los puertos.\\n- `html/index.html`: una p\xe1gina simple que dice \u201c\xa1Hola, soy Alejandro!\u201d con estilo.\\n- Permisos adecuados (`755` para la carpeta, `644` para el archivo).\\n- Puerto 8080 expuesto para ver el sitio desde el navegador.\\n\\n### \ud83d\udcdd Creemos nuestro Vagrantfile\\n\\nEl vagrantfile es nuestro archivo de configuraci\xf3n el cual levantara las infraestrucras que le solicitemos, en este caso\\nrealizaremos un laboratorio haciendo uso de **docker** y **nginx** para levantar una pagina estatica\\n\\n    ```bash title=\\"Bash\\"\\n    Vagrant.configure(\\"2\\") do |config|\\n    # Crear el archivo HTML antes de levantar el contenedor\\n    unless File.exist?(\\"html/index.html\\")\\n        Dir.mkdir(\\"html\\") unless Dir.exist?(\\"html\\")\\n        File.write(\\"html/index.html\\", \\"<h1>Hola, soy Alejandro</h1>\\\\n\\")\\n        File.chmod(0755, \\"html\\")\\n        File.chmod(0644, \\"html/index.html\\")\\n    end\\n    config.vm.box_version = \\"~> 2025.06\\"\\n    config.vm.define \\"nginx_container\\" do |nginx|\\n            nginx.vm.provider \\"docker\\" do |d|\\n            d.image = \\"nginx:latest\\"\\n            d.name = \\"nginx-dev\\"\\n            d.ports = [\\"8080:80\\"] # Acceso v\xeda localhost:8080\\n            d.remains_running = true\\n            d.volumes = [\\"#{Dir.pwd}/html:/usr/share/nginx/html:ro\\"]\\n            end\\n        end\\n    end\\n    ```\\n\\n### \ud83c\udf10 \xbfC\xf3mo lo pruebo?\\n\\n1. Aseg\xfarate de tener **Docker Desktop** instalado y corriendo.\\n2. Clona este repositorio o copia los archivos en una carpeta.\\n3. Ejecuta:\\n\\n   ```bash title=\\"Bash\\"\\n   vagrant up --provider=docker\\n   ```\\n\\n4. Si quieres detener el docker puedes usar el siguiente comando\\n\\n    ```bash title=\\"Bash\\"\\n   vagrant halt\\n   ```\\n\\n### \ud83d\udd27 \xbfQu\xe9 aprend\xed y configur\xe9?\\n\\n\u2705 Us\xe9 Vagrant para definir y gestionar el entorno.  \\n\u2705 utilice Docker (ideal para Macs con Apple Silicon).  \\n\u2705 Automatiz\xe9 la creaci\xf3n de un archivo `index.html` con un dise\xf1o sencillo y bonito.  \\n\u2705 Mont\xe9 ese archivo como volumen dentro de un contenedor NGINX.  \\n\u2705 Configur\xe9 correctamente los permisos de archivos para evitar errores como `403 Forbidden`.\\n\\n## \ud83d\ude2b Mi error\\n\\nTen encuenta que para manejar vagrant en Mac con chip con arquitectura ARM necesitas crear utilizar una confurtaci\xf3n difetente\\npor esta raz\xf3n tuve el siguiente erro.\\n\\n    ``` bash title=\\"Bash\\"  \\n        alejo@alejos-MacBook-Pro ubuntu-jummy64 % vagrant up\\n        Bringing machine \'default\' up with \'virtualbox\' provider...\\n        Command: [\\"startvm\\", \\"54267685-348f-4553-8915-acbcd4a560b0\\", \\"--type\\", \\"headless\\"]\\n\\n        Stderr: VBoxManage: error: The VM session was aborted\\n        VBoxManage: error: Details: code NS_ERROR_FAILURE (0x80004005), component SessionMachine, interface ISession\\n    ```\\n\\nEste erro es devido a que como comente aterior mente vagrant tiene un error de compatividad con la arquitectura ARM,\\npara solucionarlo solo deves  instalar **paralles** como proveedor VM.\\n\\n    ``` bash title=\\"Bash\\"\\n        vagrant plugin install vagrant-parallels\\n        config.vm.box = \\"generic/ubuntu2204-arm64\\"\\n    ```\\n\\nTambien tuve que usar una imagen que vieniera para la arquitectura **ARM**\\n\\n    ``` bash title=\\"Bash\\"\\n        config.vm.box = \\"generic/ubuntu2204-arm64\\"\\n    ```\\n\\n### Gracias \ud83e\udd29 por llegar hasta este punto\\n\\nA\xfan quedan muchas cosas por explorar de **vagrant**, pero te agradezco por tomarte el tiempo de entrar a este blog. El c\xf3digo implementado\\nlo puedes encontrar en m\xed git-hub [alejo95/vagrant-nginx-lab](https://github.com/alejo95/vagrant-nginx-lab)"},{"id":"liquibase","metadata":{"permalink":"/blog/liquibase","editUrl":"http://iamdevops.site/my_page/edit/main/blog/2025/repository_management/liquibase.md","source":"@site/blog/2025/repository_management/liquibase.md","title":"Database DevOps con Liquibase","description":"Hola, amigos \ud83d\ude03 DevOps. Hoy hablaremos sobre Database DevOps.","date":"2025-06-12T00:00:00.000Z","tags":[{"inline":false,"label":"Liquibase","permalink":"/blog/tags/tags/liquibase"},{"inline":false,"label":"Database","permalink":"/blog/tags/tags/database"},{"inline":false,"label":"DevOps","permalink":"/blog/tags/tags/devops"},{"inline":false,"label":"Database DevOps","permalink":"/blog/tags/tags/databasedevops"}],"readingTime":17.11,"hasTruncateMarker":true,"authors":[{"name":"Alejandro Ram\xedrez","title":"Software Engineer | DevOps | Back-end Developer","url":"https://alejo95.github.io/my_page/about_me","description":"Alejandro Ram\xedrez is a back-end developer with a passion for creating efficient and scalable applications. He has a strong background in software development and is always eager to learn new technologies.\\n","social":{"linkedin":"https://www.linkedin.com/in/alejandro-ramirez-95/"},"imageURL":"https://avatars.githubusercontent.com/u/30883786?s=96&v=4","key":"alejandro-ramirez","page":null}],"frontMatter":{"slug":"liquibase","sidebar_position":3,"title":"Database DevOps con Liquibase","tags":["liquibase","database","devops","databasedevops"],"authors":"alejandro-ramirez","date":"2025-06-12T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Aprendiendo iaC con Vagrant","permalink":"/blog/vagrant"},"nextItem":{"title":"Nginx","permalink":"/blog/entendiendo_nginx"}},"content":"\x3c!-- truncate --\x3e\\n\\nHola, amigos \ud83d\ude03 DevOps. Hoy hablaremos sobre **Database DevOps**.\\n\\nComo bien sabemos, DevOps ha sido clave en el desarrollo de aplicaciones, especialmente al facilitar los procesos de entrega\\ncontin\xfaa e integrando a los equipos de desarrollo y operaciones en flujos de trabajo \xe1giles y optimizados.\\n\\nSin embargo, muchas veces durante el desarrollo de una aplicaci\xf3n omitimos la importancia de las bases de datos. Nos enfocamos en\\nescribir c\xf3digo y en contar con herramientas que permitan hacer Rollback de nuestro c\xf3digo de forma r\xe1pida en caso de alg\xfan error.\\nPero hacer Rollback en una base de datos puede ser mucho m\xe1s delicado y perjudicial si no se maneja correctamente.\\n\\nPor eso, dentro de DevOps se han implementado herramientas y pr\xe1cticas que nos permiten gestionar los cambios en bases de datos \ud83d\udcc8\\nde manera segura y eficiente. En este blog veremos c\xf3mo usar **Liquibase** y c\xf3mo puede ayudarnos a mejorar nuestro flujo de\\ntrabajo y de esta forma mantener nuestra base de datos de una forma consistente.\\n\\n    <img src=\\"/img/blog/devops/databasedevops.png\\" alt=\\"contenedor\\" width=\\"600\\" />\\n\\n## \xbfQues Database DevOps? \ud83d\udc68\u200d\ud83d\udcbb\\n\\n    Es traer las pr\xe1cticas y principios implementados en el mundo del **DevOps** buscando garantizar que el c\xf3digo de las bases de\\n    los datos se incluyen en el mismo proceso que el c\xf3digo de desarrollo. Con esto buscamos solucionar el cuello de botella que se \\n    puede presentar al momento de generar los cambios en el c\xf3digo de la base de datos, ya que en muchos de los casos estos cambios \\n    tienen que ser validados por un **DBA**(data base administrador) y facilit\xe1ndole el trabajo, ya que ellos se encargaran de \\n    enfocarse en temas respecto a la base de datos.\\n\\n## \xbfPorque surge esta problematica? \ud83d\ude27\\n\\n    Esta problem\xe1tica se da debido a que muchas veces los programadores realizan actualizaciones en el c\xf3digo fuente de las\\n    aplicaciones que algunas ocasiones implementa cambios en el c\xf3digo de la base de datos, estos cambios tenemos que llevarlos \\n    a cabo haciendo uso de SQL.\\n\\n    Para entender esto de una forma m\xe1s f\xe1cil dejar\xe9 un diagrama que muestra el flujo manual que se suele llevar por un equipo\\n    convencional de DBA generando pausa entre cada paso (generando un cuello de botella).\\n    \\n        <img src=\\"/img/blog/devops/vidadeldesarollo.png\\" alt=\\"contenedor\\" width=\\"700\\" />\\n\\n    debido a que estos procesos funcionan de una forma manual, deben llevarse a cabo las revisiones del c\xf3digo de base datos\\n    suele ser lo ultimo en realizarse suele generar un retraso en el lanzamiento. Esto genera un problema, pues genera un retraso\\n    generando problemas pues la validaci\xf3n y revisi\xf3n no son eficientes. Todo proceso de cambio en la base de datos es simplemente\\n    un obst\xe1culo.\\n\\n## Una soluci\xf3n entre muchas \ud83d\udd27\\n\\n    En este caso como hemos hablado desde un principio aqu\xed es donde entra nuestra soluci\xf3n **Liquidbase** como una herramienta echa\\n    para quitar esas paradas innecesarias, donde el **DBA** debe revisar los cambios hasta la fase final, sin la necesidad de hacer\\n    las revisiones en etapas tempranas del proceso y as\xed empaquetar todo el c\xf3digo.\\n\\n    <img src=\\"/img/blog/devops/unficacionvidadelsoftware.png\\" alt=\\"contenedor\\" width=\\"700\\" />\\n\\n    Una soluci\xf3n DevOps de bases de datos como [Liquibase](https://www.liquibase.com/how-liquibase-works). Permite a los equipos \\n    automatizar y gestionar la gesti\xf3n de cambios para optimizar este cuello de botella y acelerar los procesos de las \\n    aplicaciones. Esto es lo que hace que esta soluci\xf3n sea tan valiosa.\\n    \\n    **Liquibase** Nos permite gestionar estas actualizaciones de una forma f\xe1cil y que igual forma nos permite realizar un Rollback\\n    de una forma f\xe1cil y r\xe1pida, ayud\xe1ndonos a mantener la consistencia en la base datos, adem\xe1s nos permite llevar un controlo de\\n    versiones, la cual realizar de una forma inicial manualmente y en el futuro tambi\xe9n nos permite automatizar este proceso.\\n\\n## Laboratorio Liquibase \ud83e\uddea\\n\\n    Hoy realizare la implementaci\xf3nde liquidase si quieres implementarlodejare los paso para que lo sigas y tambi\xe9npuedas\\n    implementarlo en t\xfa m\xe1quina si quieres implementarlo a un **CI/CD** debemos realizar otros paso, en esta primer guia,\\n    encuentrasla implementaci\xf3n de liquibase donde el objetivo es aprender como liquibase gestiona cambios en las bases de datos de\\n    forma controlada usando archivos de tipo chagelog( YAML, XML, JSON o SQL). **Vamos! \ud83e\udd73**\\n\\n### \u2699\ufe0f Requisitos previos\\n\\n    antes de comenzar debemos tener los siguiente recursos instalados en nuestro equipo \ud83d\udcbb en este caso realizamos la configuraci\xf3n\\n    en macOs, dejare una referencia para que instales en Linux.\\n    1. **Docker**: lo usaremos para levantar nuestra base de datos de prueba y nuestro liquibase\\n    2. **Editor de codigo**: En mi caso usare VS Code\\n    3. **Java JDK** 11 o Superior  (opcional)\\n    4. **Liquibase(CLI)** Herramienta a usar (opcional)\\n\\n   \\n    ### Instalar Docker (Necesario)\\n\\n        Para crear bases de datos de prueba sin instalar nada m\xe1s en tu Mac Ve a https://docs.docker.com/desktop/mac/install/\\n        Descarga e instala Docker Desktop para Mac.\\n\\n        Abre Docker Desktop y aseg\xfarate que est\xe9 corriendo.\\n\\n        Verifica desde Terminal:\\n\\n        ```bash title=\\"Bash\\"\\n        docker --version\\n        docker compose version\\n        ```\\n\\n        <img src=\\"/img/blog/devops/dockerinstall.png\\" alt=\\"Terminal mostrando la versi\xf3n de docker instalada, texto \\n        visible: docker version 17.0.2 2022-01-18, ambiente de desarrollo en macOS, tono informativo y neutral\\" width=\\"600\\" />\\n        \\n\\n    ### Instalar Homebrew (si no lo tienes)\\n\\n        Si no tienes Homebrew, instala con:\\n\\n        ```bash title=\\"Bash\\"\\n        /bin/bash -c \\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\\"\\n        ```\\n\\n    ### JAVA JDK (opcional)\\n\\n        Verificamos si tenemos intalado java \\n\\n        ```bash title=\\"Bash\\"\\n        java -version\\n        ```\\n\\n        En caso de que lo tengas instalado continua al siguiente paso de instalaci\xf3n de liquibase\\n\\n    -  Instalaci\xf3n\\n\\n        Para instalarlo tendremos que usar el siguiente comando en caso de usar hombrew\\n\\n        ```bash title=\\"Bash\\"\\n        brew install openjdk@17\\n        ```\\n\\n    -  A\xf1ade a tu PATH (varia segun la versi\xf3n estalada)\\n\\n        ```bash title=\\"Bash\\"\\n        sudo ln -sfn $(brew --prefix openjdk@17)/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk\\n        echo \'export PATH=\\"/usr/local/opt/openjdk@17/bin:$PATH\\"\' >> ~/.zshrc\\n        source ~/.zshrc\\n        ```\\n\\n    -  Volvemos a repetir la verficaci\xf3n del JDK\\n\\n        Verificamos si tenemos instalado Java.\\n\\n        ```bash title=\\"Bash\\"\\n        java -version\\n        ```\\n        Si est\xe1 instalado, ver\xe1s una salida similar a la siguiente imagen:\\n\\n        <img src=\\"/img/blog/devops/terminal_susses_jdk.png\\" alt=\\"Terminal mostrando la versi\xf3n de Java instalada, texto visible: openjdk version 17.0.2 2022-01-18, ambiente de desarrollo en macOS, tono informativo y neutral\\" width=\\"600\\" />\\n\\n    ### Instalemos el CLI de liquibase (Opcional)\\n\\n        La forma mas facil de inplementarlo es unsado brew en el caso de mac\\n\\n        ```bash title=\\"Bash\\"\\n        brew install liquibase\\n        ```\\n        verifica la instalaci\xf3n \\n\\n        ```bash title=\\"Bash\\"\\n        liquibase --version\\n        ```\\n        una vez instalado si lo realizaste des de tu terminal en mac si puebas el comando de version si sale algo\\n        como la siguiente imagen todo estara correctamente y podremos seguir sin problema \ud83d\ude03.\\n\\n            <img src=\\"/img/blog/devops/liquibase_install.png\\" alt=\\"Terminal mostrando la versi\xf3n de liquibase instalada, texto \\n            visible: openjdk version 17.0.2 2022-01-18, ambiente de desarrollo en macOS, tono informativo y neutral\\" width=\\"600\\" />\\n    \\n    ### Instalar cliente PostgreSQL (opcional)\\n    \\n    Para interactuar con la base de datos de uba forna m\xe1s facil puede usar al igual que yo el cliente des Postgres:\\n\\n         ```bash\\n        brew install postgresql\\n        Luego \\n         ```\\n    \\n    prueba conectarte una vez este levantes el **docker-compose**:\\n\\n        ```bash\\n        psql -h localhost -U liquibase -d liquibase_demo\\n        Contrase\xf1a: liquibase\\n        ```\\n\\n        | Opci\xf3n              | Significado                                          |\\n        | ------------------- | ---------------------------------------------------- |\\n        | `psql`              | Cliente de l\xednea de comandos de PostgreSQL           |\\n        | `-h localhost`      | Host de la base de datos (en este caso, `localhost`) |\\n        | `-U liquibase`      | Usuario con el que se conecta (`liquibase`)          |\\n        | `-d liquibase_demo` | Base de datos a la que se conecta (`liquibase_demo`) |\\n\\n---\\n\\n### Iniciemos con nuestro laboratorio \ud83d\ude03\\n\\n    Genial!!, Si todo t\xe9 sali\xf3 bien, en este punto ya deber\xedamos tener instalados todo lo necesario para poder iniciar \\n    a colocar las primeras l\xedneas de c\xf3digo para implementar nuestro laboratorio \ud83e\udd73.\\n\\n\\n    para realizar nuestra prueba inicial implementaremos la siguiente estructura de carpetas\\n\\n    ### \ud83d\uddc2\ufe0f estructura del proyecto\\n        \\n        esta estructuras es una estructura b\xe1sica solamente realizada para la prueba, para realizar un proyecto a un nivel\\n        mas producci\xf3n deber\xe1s realizar algunos cambios que tal vez dejar\xe9 en otro apartado, ya que lo que buscamos en este\\n        laboratorio es experimentar y entender como funciona **liquibase**.\\n\\n        ```bash title=\\"Tree\\"\\n        liquibase-lab/\\n        \u251c\u2500\u2500 changelogs/\\n        \u2502   \u251c\u2500\u2500 db.changelog-master.yaml\\n        \u251c\u2500\u2500 docker-compose.yml\\n        \u251c\u2500\u2500 liquibase.properties\\n        \u251c\u2500\u2500 README.md\\n        \u2514\u2500\u2500 .gitignore (opcional)\\n        ```\\n\\n        #### \ud83d\udcdd Descripci\xf3n de Archivos y Carpetas\\n\\n        | Archivo/Carpeta            | Descripci\xf3n                                                               |\\n        | -------------------------- | ------------------------------------------------------------------------- |\\n        | `changelogs/`              | Carpeta que contiene todos los archivos de cambios (changelogs).          |\\n        | `db.changelog-master.yaml` | Changelog principal que act\xfaa como punto de entrada e incluye otros.      |\\n        | `001-*.yaml`, `002-*.yaml` | Archivos con cambios individuales, ordenados por prefijo num\xe9rico.        |\\n        | `docker-compose.yml`       | Archivo para levantar la base de datos PostgreSQL con Docker.             |\\n        | `liquibase.properties`     | Archivo de configuraci\xf3n de Liquibase: conexi\xf3n, changelog, credenciales. |\\n        | `README.md`                | Documentaci\xf3n y notas del laboratorio.                                    |\\n        | `.gitignore`               | Opcional. Ignora archivos temporales, logs, etc., si usas Git.            |\\n\\n        #### \ud83e\ude84 Crea rapidamente la estructura desde cero\\n\\n        Con el siguiente comando podr\xe1s crear toda la estructur\xe1 sin ning\xfan problema desde tu terminal, estos tambi\xe9n sirven en\\n        linux\\n\\n        ```bash title=\\"Bash\\"\\n        > $ mkdir liquibase-lab\\n        > $ cd liquibase-lab\\n        > $ mkdir changelogs\\n        > $ touch docker-compose.yml liquibase.properties changelogs/db.changelog-master.yaml README.md\\n        ```\\n    \\n        Una vez ya tengas la estructura creada puedes abrir tu VS Code y utilizarlo para seguir con el siguiente paso\\n\\n        <img src=\\"/img/blog/devops/liquibasevscode.png\\" width=\\"600\\" />\\n\\n    ## \ud83c\udfd7\ufe0f Cremos nuestro Docker-compose\\n    \\n    Ahora escribiremos el siguiente c\xf3digo que lleva la configuraci\xf3n de nuestro compose, junto con los diferentes\\n    vol\xfamenes que nos ayudaran a mantener que persista nuestra data\\n\\n    ```bash title=\\"Docker-Compose\\"\\n        services:\\n        db:  # Servicio de base de datos PostgreSQL\\n            image: postgres:14  # Imagen oficial de PostgreSQL, versi\xf3n 14\\n            container_name: liquibase_db  # Nombre del contenedor para referencia f\xe1cil\\n            environment:  # Variables de entorno para crear la base de datos inicial\\n            POSTGRES_USER: liquibase      # Usuario con permisos\\n            POSTGRES_PASSWORD: liquibase  # Contrase\xf1a del usuario\\n            POSTGRES_DB: liquibase_demo   # Nombre de la base de datos a crear\\n            ports:\\n            - \\"5432:5432\\"  # Expone el puerto de PostgreSQL al host local\\n            networks:\\n            - liquibase-net  # Conecta este servicio a una red personalizada\\n            healthcheck:  # Verifica que PostgreSQL est\xe9 listo antes de continuar\\n            test: [\\"CMD\\", \\"pg_isready\\", \\"-U\\", \\"liquibase\\"]\\n            interval: 5s\\n            timeout: 5s\\n            retries: 5\\n\\n        liquibase:  # Servicio para ejecutar comandos de Liquibase CLI\\n            image: liquibase/liquibase:latest  # Imagen oficial de Liquibase\\n            container_name: liquibase_cli  # Nombre del contenedor de Liquibase\\n            depends_on:\\n            db:\\n                condition: service_healthy  # Espera a que la base de datos est\xe9 lista\\n            volumes:  # Mapea archivos locales al contenedor\\n            - ./changelogs:/liquibase/changelogs  # Cambios en la BD\\n            - ./liquibase.properties:/liquibase/liquibase.properties  # Configuraci\xf3n\\n            working_dir: /liquibase  # Carpeta por defecto donde ejecuta comandos\\n            entrypoint: [\\"tail\\", \\"-f\\", \\"/dev/null\\"]  # Mantiene el contenedor en ejecuci\xf3n para uso interactivo\\n            networks:\\n            - liquibase-net  # Se conecta a la misma red que la BD\\n\\n        networks:\\n        liquibase-net:  # Red personalizada para que los servicios se comuniquen por nombre\\n\\n    ```\\n    ## Creemos nuestro liquibase.properties\\n\\n    Si seguiste la gu\xeda, hasta este punto en los archivos necesarios que creamos encontraras el ***liquibase.properties***\\n    el cual es el archivo que contendr\xe1 la configuraci\xf3n de nuestro liquibase, es el encargado de decirle a liquibase **como\\n    conectarse ala base de datos** y donde encontrar los archivos de cambios(changelogs).\\n\\n\\n        ```bash title=\\"liquibase.properties\\"\\n        # liquibase.properties\\n        changeLogFile: changelogs/db.changelog-master.yaml\\n        url: jdbc:postgresql://db:5432/liquibase_demo\\n        username: liquibase\\n        password: liquibase\\n        driver: org.postgresql.Driver\\n        logLevel: info\\n        ```\\n\\n    | OJO: en el url, el host es db, el nombre del servicio del contenedor.\\n    \\n    | Propiedad       | Descripci\xf3n                                                                                 | Ejemplo                                    |\\n    | --------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------ |\\n    | `changeLogFile` | Ruta al archivo principal de cambios de base de datos (changelog).                          | `changelogs/db.changelog.yaml`             |\\n    | `url`           | URL de conexi\xf3n JDBC que indica el tipo de base de datos, host, puerto y nombre de la base. | `jdbc:postgresql://db:5432/liquibase_demo` |\\n    | `username`      | Usuario con permisos para ejecutar cambios en la base de datos.                             | `liquibase`                                |\\n    | `password`      | Contrase\xf1a del usuario de la base de datos.                                                 | `liquibase`                                |\\n    | `driver`        | Clase del driver JDBC correspondiente al motor de base de datos.                            | `org.postgresql.Driver`                    |\\n\\n\\n    ## \ud83e\udde0 Vamos a crear nuestro changelog\\n\\n    \xbfQu\xe9 hace db.changelog-master.yaml?Es un archivo maestro que organiza los cambios en la base de datos. Su funci\xf3n principal es referenciar otros archivos de \\n    cambios (por orden y modularidad), o contener directamente las instrucciones (changeSets) que Liquibase aplicar\xe1.\\n\\n    En este caso tenemos dos formas para poder crear nuestro **changelog** en este ejemplo dejar\xe9 las referencias a las dos formas, para que entiendas que podemos\\n    hacer.\\n\\n    - opci\xf3n 1\\n        En este caso se implementa un solo archivo maestro que contendra todos los **changeSets**\\n\\n        ```bash title=\\"databaseChangeLog\\"\\n        databaseChangeLog:\\n        - changeSet:\\n            id: 001\\n            author: alejo\\n            changes:\\n                - createTable:\\n                    tableName: users\\n                    columns:\\n                    - column:\\n                        name: id\\n                        type: UUID\\n                        constraints:\\n                            primaryKey: true\\n                    - column:\\n                        name: name\\n                        type: VARCHAR(100)\\n        ```\\n        \\n        De esta forma tendr\xe1s que tener el proyecto si utilizas esta opci\xf3n.\\n\\n        <img src=\\"/img/blog/devops/changelogmaster.png\\" width=\\"600\\" />\\n        | \u26a0\ufe0f Esto es \xfatil en proyectos peque\xf1os o cuando prefieres tener todo en un solo archivo lo cual puede generar al gunos problemas a largo plazo\\n    \\n    - opci\xf3n 2\\n        En este caso se implementa un archivo que contendr\xe1 todos los modelos de (changeSets), en el que tendremos las rutas de los **changeSets**\\n\\n        ```bash title=\\"databaseChangeLog-master\\"\\n        # changelogs/db.changelog-master.yaml\\n        databaseChangeLog:\\n        - include:\\n            file: changelogs/001-init-schema.yaml\\n        ```\\n        | Cada changeSet es \xfanico por id + author. No repitas estos valores.\\n\\n\\n        ```bash title=\\"changelogs/001-init-schema.yaml\\"\\n            databaseChangeLog:\\n            - changeSet:\\n                id: 001\\n                author: alejo\\n                changes:\\n                    - createTable:\\n                        tableName: users\\n                        columns:\\n                        - column:\\n                            name: id\\n                            type: UUID\\n                            constraints:\\n                                primaryKey: true\\n                        - column:\\n                            name: name\\n                            type: VARCHAR(100)\\n                        - column:\\n                            name: email\\n                            type: VARCHAR(150)\\n        ```\\n\\n       <img src=\\"/img/blog/devops/liquivasetreeprod.png\\" width=\\"600\\" />\\n        \\n        \u2705 Este modelo de carpetas te permitir\xe1 escalar de una forma m\xe1s f\xe1cil y poder versionar todos tus cambios de una forma eficiente, en caso de que quieras\\n        realizar alg\xfan cambio\\n\\n### Vamos a correr nuestro poyecto\\n\\n    Perfecto si llegaste hasta aqu\xed ya podemos correr los comandos de nuestro \ud83d\udc33 **docker-compose** para correr el proyecto\\n\\n    \u2705 1. Levantar los servicios en segundo plano\\n    Esto crea y arranca los contenedores:\\n\\n    ```bash title=\\"Bash\\"\\n    docker compose up -d\\n    ```\\n    | \ud83d\udd0d Esto arrancar\xe1 el contenedor de PostgreSQL y lo dejar\xe1 corriendo en segundo plano ya que usamos **-d**.\\n\\n    \u2705 2. Verificar que la base de datos est\xe1 lista\\n    Liquibase depende de que la base de datos est\xe9 lista. Aseg\xfarate de que el servicio db est\xe9 healthy:\\n\\n    ```bash title=\\"Bash\\"\\n    docker compose ps\\n    ```\\n    veras algo como esto\\n    \\n    <img src=\\"/img/blog/devops/liquivasetreeprod.png\\" width=\\"600\\" />\\n\\n    ### \ud83e\udde0 \xbfC\xf3mo sabe Liquibase qu\xe9 ya corri\xf3?\\n\\n    Liquibase registra los changeSets ejecutados en una tabla llamada DATABASECHANGELOG. As\xed evita repetir cambios y permite auditar qu\xe9 se aplic\xf3, cu\xe1ndo y por qui\xe9n.\\n\\n    <img src=\\"/img/blog/devops/liquibaserun.png\\" width=\\"600\\" />\\n\\n    En este punto ya tenemos nuestros servicios corriendo, y con ya podremos ejecutar\\n\\n    ```bash title=\\"Bash\\"\\n    docker exec -it liquibase_cli liquibase update\\n    ```\\n    Si todo te sale bien, deber\xe1s ver algo como se ve en la imagen.\\n\\n    <img src=\\"/img/blog/devops/primerejecucion.png\\" width=\\"600\\" />\\n    | Esto ejecutar\xe1 todos los changeSets del archivo db.changelog-master.yaml y aplicar\xe1 los cambios en la base de datos PostgreSQL.\\n\\n    ### \ud83e\udde0 \xbfPor qu\xe9 se crea autom\xe1ticamente?\\n    La base de datos se crea autom\xe1ticamente porque se lo est\xe1s indicando al contenedor de PostgreSQL con POSTGRES_DB al inicio.\\n\\n    <img src=\\"/img/blog/devops/conectiondb.png\\" width=\\"600\\" />\\n\\n    y en nuestra base de datos **Postgres** podremos ver lo siguiente\\n\\n    <img src=\\"/img/blog/devops/basededatos.png\\" width=\\"600\\" />\\n\\n    Cuando corremos este comando **liquibase** se crearan dos tablas `databasechangelog` y `databasechangeloglock`\\n    \\n    | Tabla                             | \xbfPara qu\xe9 sirve?                          |\\n    |-----------------------------------|-------------------------------------------|\\n    | `databasechangelog`               | Historial de cambios ya aplicados         |\\n    | `databasechangeloglock`           | Evita conflictos por ejecuci\xf3n simult\xe1nea |\\n\\n    Genial hasta este punto ya tenemos nuestro proyecto creado y corriendo, ahora realizaremos una actualizaci\xf3n a la tabla `users` que creamos\\n    donde crearemos un `changeSet`\\n\\n    - Creemos otro archivo dentro de nuestra carpeta `changelogs` con el nombre `002-create-users-table.yaml`\\n\\n    ```bash title=\\"Bash\\"\\n    databaseChangeLog:\\n    - changeSet:\\n        id: 002\\n        author: alejo\\n        changes:\\n            - addColumn:\\n                tableName: users\\n                columns:\\n                - column:\\n                    name: birthdate\\n                    type: DATE\\n    ```\\n    |Cada changeSet es \xfanico por id + author. No repitas estos valores.\\n\\n    En este caso aremos un cambio ala tabla `users` donde agregaremos la columna de **birthdate**\\n\\n    Ya creado nuestro archivo ejecutaremos nuevamente nuestro comando, que generara los cambios en la base de datos.\\n\\n    ```bash title=\\"Bash\\"\\n    docker exec -it liquibase_cli liquibase update\\n    ```\\n    al ejecutar deber\xe1 salir lo que se ve en la siguiente imagen\\n\\n    <img src=\\"/img/blog/devops/runliquibasechange.png\\" width=\\"600\\" />\\n\\n    Para comprobar el cambio te puedes conectar ala base de datos y validar que se crearon los campos como los definimos\\n\\n    ### \xbfC\xf3mo funciona el rollback?\\n\\n    Liquibase puede revertir cambios de varias maneras, pero solo si sabe c\xf3mo hacerlo. Esto es posible si:\\n    \\n    El changeSet tiene rollback autom\xe1tico (por ejemplo, createTable se puede revertir con dropTable).\\n    T\xfa defines expl\xedcitamente el rollback en tu changeSet.\\n\\n    ### Como podemos rollback\\n\\n    Liquibase permite revertir usando distintos comandos:\\n    \\n\\n    #### \ud83d\udd01 Ejemplo de rollback\\n\\n    - Agregamos a nuestro changelog nuestra actualizaci\xf3n\\n\\n    ```bash title=\\"Bash\\"\\n    databaseChangeLog:\\n    - changeSet:\\n        id: 003\\n        author: alejo\\n        changes:\\n            - addColumn:\\n                tableName: users\\n                columns:\\n                - column:\\n                    name: age\\n                    type: INT\\n        rollback:\\n            - dropColumn:\\n                columnName: age\\n                tableName: users\\n    ```\\n    Este archivo:\\n\\n      - Agrega una columna age a la tabla users.\\n      - Define que el rollback elimina esa columna.\\n\\n    - Actualizamos nuestr archivo \ud83d\udcd8 `db.changelog-master.yaml`\\n\\n        ```bash title=\\"Bash\\"\\n        databaseChangeLog:\\n            - include:\\n                file: changelogs/001-create-table-user.yaml\\n            - include:\\n                file: changelogs/002-insert-users.yaml\\n            - include:\\n                file: changelogs/003-add-column-age.yaml\\n        ```\\n    \\n    Deberas tener algo asi, como se ve en la siguiente imagen\\n\\n     <img src=\\"/img/blog/devops/rollbackliquibase.png\\" width=\\"600\\" />\\n\\n    Hora vamos a ejecutarlo, En este caso corremos primeros nuestra actualizaci\xf3n, donde se agregar\xe1 `ege`.\\n    \\n    ```bash title=\\"Bash\\"\\n        docker exec -it liquibase_cli liquibase update\\n    ```\\n    Como s\xe9 que todo t\xe9 sali\xf3 bien deber\xe1 salirte en tu consola algo como esto y en tu tabla debi\xf3 aparecer la columna `ege`\\n\\n    <img src=\\"/img/blog/devops/addege.png\\" width=\\"600\\" />\\n\\n    Para realizar el rollback tienes varias opciones, aqu\xed dejar\xe9 dos que puedes usar sin problema\\n\\n    #### \ud83d\udd01 1. Rollback de un changeSet espec\xedfico (desde 003)\\n\\n    ```bash title=\\"Bash\\"\\n    docker compose exec liquibase liquibase rollbackCount 1\\n    ```\\n    Este revierte el \xfaltimo cambio (003), usando el bloque rollback.\\n\\n    #### \ud83d\udd01 2. Rollback por ID\\n\\n    ```bash title=\\"Bash\\"\\n        docker compose exec liquibase liquibase liquibase rollbackToDate \\"2025-06-11T20:00:00\\"\\n    ```\\n    Este revierte todos los cambios hasta (pero no incluyendo) el changeSet con id: 002.\\n\\n    Si se aplica el rollback volveremos a la versi\xf3n 002 de una forma f\xe1cil.\\n\\n    <img src=\\"/img/blog/devops/rollbacksucces.png\\" width=\\"600\\" />\\n\\n### Tabla comandos \ud83c\udfae\\n\\n    Aqu\xed encontrar\xe1s una serie de comandos que puedes ejecutar para que sigas probando las otras funcionalidades que tiene liquibase. \\n    Te invito a probar y testear todo lo que quieras.\\n\\n    Puedes agregar `exec -it` para ver hacer la terminal interactiva\\n\\n    | Comando                                           | \xbfPara qu\xe9 sirve?                                                                 |\\n    |--------------------------------------------------|----------------------------------------------------------------------------------|\\n    | `docker compose run liquibase update`            | Aplica todos los `changeSet` pendientes definidos en el changelog maestro.      |\\n    | `docker compose run liquibase status`            | Muestra qu\xe9 cambios (changeSets) a\xfan no se han aplicado a la base de datos.     |\\n    | `docker compose run liquibase history`           | Lista todos los `changeSets` ya aplicados con detalles (fecha, autor, id).      |\\n    | `docker compose run liquibase rollbackCount 1`   | Revierte el \xfaltimo cambio aplicado (puedes cambiar `1` por otro n\xfamero).        |\\n    | `docker compose run liquibase rollbackToDate 2024-01-01` | Revierte todos los cambios hechos despu\xe9s de una fecha espec\xedfica.     |\\n    | `docker compose run liquibase validate`          | Valida el archivo changelog, revisa errores de sintaxis o duplicados.           |\\n    | `docker compose run liquibase clearCheckSums`    | Limpia los checksums para forzar revalidaci\xf3n de cambios. \xdatil si editaste sets.|\\n    | `docker compose run liquibase changelogSync`     | Marca todos los cambios como aplicados sin ejecutarlos (\xa1\xfatil en producci\xf3n!).   |\\n\\n## Errores\\n\\n    Como siempre cometemos errores, durante la primera configuraci\xf3n implementan mal la conexi\xf3n a la base de datos\\n    debido a que estaba apuntando al local host, el cual hace que apunte dentro de su propio contenedor, por eso no lo encontraba \\n    entonces esto se lo correg\xed  el par\xe1metro url.\\n\\n    ```bash title=\\"Error\\"\\n    # liquibase.properties\\n    Connection could not be created to jdbc:postgresql://localhost:5432/liquibase_demo\\n    ```\\n     | Est\xe1s diciendo que se conecte a localhost (jdbc:postgresql://localhost:5432)\\n\\n### Gracias \ud83e\udd29 por llegar hasta este punto\\n\\nA\xfan quedan muchas cosas por explorar de **liquibase**, pero te agradezco por tomarte el tiempo de entrar a este blog. El c\xf3digo implementado\\nlo puedes encontrar en m\xed git-hub [alejo95/Liquibase-lab](https://github.com/alejo95/liquibase-lab)\\n\\n### Mi punto de vista\\n\\nEn realidad, es genial este tipo de herramientas que facilitan la actualizaci\xf3n de las bases de datos usando pr\xe1cticas\\ndel mundo **DevOps**, para m\xed fue una experiencia genial, ya que me permite entender de una forma f\xe1cil la implementaci\xf3n\\nde actualizaciones r\xe1pidas a la base de datos, aparte de eso, cuenta con muchas cualidades que ayudan a esta herramienta mejore\\nel flujo de trabajo es un **100%**, ya que logramos romper esa barra entre el equipo.\\n\\nDejar\xe9 una lista de 10 ventajas que tiene liquibase\\n\\n| N\xba | Ventaja                              | Descripci\xf3n                                                                                  |\\n|----|--------------------------------------|----------------------------------------------------------------------------------------------|\\n| 1  | **Control de versiones**            | Lleva historial detallado de los cambios en la base de datos, como Git para el c\xf3digo.      |\\n| 2  | **Rollback autom\xe1tico**             | Permite revertir cambios f\xe1cilmente usando tags, fechas o n\xfamero de cambiosets.             |\\n| 3  | **Seguridad y consistencia**        | Asegura que los cambios se apliquen una sola vez y en el orden correcto.                    |\\n| 4  | **Integraci\xf3n con CI/CD**           | Se puede integrar en pipelines para aplicar cambios autom\xe1ticamente.                        |\\n| 5  | **Soporte multiplataforma**         | Compatible con PostgreSQL, MySQL, Oracle, SQL Server, H2, entre otros.                      |\\n| 6  | **Soporte para m\xfaltiples formatos** | Cambios escritos en XML, YAML, JSON o SQL, seg\xfan la preferencia del equipo.                 |\\n| 7  | **Ejecuci\xf3n simulada (dry run)**    | Permite previsualizar cambios sin aplicarlos realmente (`updateSQL`, `rollbackSQL`).        |\\n| 8  | **Gesti\xf3n de bloqueos**             | Usa locking para evitar conflictos cuando varios procesos intentan modificar la DB.         |\\n| 9  | **Historial centralizado**          | Registra todos los cambios aplicados en tablas internas (`databasechangelog`).              |\\n| 10 | **Comparaci\xf3n de esquemas**         | `liquibase diff` compara dos bases de datos y genera un changelog autom\xe1ticamente.          |"},{"id":"entendiendo_nginx","metadata":{"permalink":"/blog/entendiendo_nginx","editUrl":"http://iamdevops.site/my_page/edit/main/blog/2025/repository_management/blog_nginx.md","source":"@site/blog/2025/repository_management/blog_nginx.md","title":"Nginx","description":"Durante alg\xfan tiempo me he topado con el problema de entender qu\xe9 es Nginx y c\xf3mo funciona, debido a que es un","date":"2025-05-15T00:00:00.000Z","tags":[{"inline":false,"label":"Nginx","permalink":"/blog/tags/tags/nginx"},{"inline":false,"label":"Redes","permalink":"/blog/tags/tags/redes"}],"readingTime":4.74,"hasTruncateMarker":true,"authors":[{"name":"Alejandro Ram\xedrez","title":"Software Engineer | DevOps | Back-end Developer","url":"https://alejo95.github.io/my_page/about_me","description":"Alejandro Ram\xedrez is a back-end developer with a passion for creating efficient and scalable applications. He has a strong background in software development and is always eager to learn new technologies.\\n","social":{"linkedin":"https://www.linkedin.com/in/alejandro-ramirez-95/"},"imageURL":"https://avatars.githubusercontent.com/u/30883786?s=96&v=4","key":"alejandro-ramirez","page":null}],"frontMatter":{"slug":"entendiendo_nginx","sidebar_position":1,"title":"Nginx","tags":["nginx","redes"],"authors":"alejandro-ramirez","date":"2025-05-15T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Database DevOps con Liquibase","permalink":"/blog/liquibase"},"nextItem":{"title":"Manejo del repositorio","permalink":"/blog/manejo-del-repositorio"}},"content":"\x3c!-- truncate --\x3e\\n\\n    Durante alg\xfan tiempo me he topado con el problema de entender qu\xe9 es Nginx y c\xf3mo funciona, debido a que es un\\n    poco confuso, ya que muchas personas hablan de que es un servidor web, un balanceador de cargas, tambi\xe9n un Proxy\\n    inverso y m\xe1s, claro es porque tiene todas estas funcionalidades, as\xed que en este blog exploraremos juntos c\xf3mo\\n    funciona y realizaremos algunas pruebas para ver sus diferentes usos.\\n\\n        <img src=\\"/img/blog/nginx/nginx.png\\" alt=\\"contenedor\\" width=\\"600\\" />\\n\\n## \xbfQu\xe9 es Nginx? \ud83e\udee3\\n\\n    En principio es un software de c\xf3digo abierto que funciona principalmente como servidor web, que tal y como hablamos\\n    en un principio tiene diferentes funcionalidades, ya que fue creado para mejorar el rendimiento y la estabilidad de\\n    las aplicaciones web, en especial cuando hablamos de entornos de alta demanda, o sea cuando tenemos una aplicaci\xf3n que\\n    tienen muchos peticiones.ndo hablamos de entornos de alta demanda, osea cuando tenemos una aplicaci\xf3n que tienen\\n    muchos peticiones.\\n\\n### Funcionalidaes de Nginx \ud83e\uddf0\\n\\nNginx es un servidor web que puede acturar como:\\n\\n    - Servidor web startico: sirve para manejar archivos como html, css y imagenes.\\n    - Poxy inverso: reenvia peticiones a otros setvidores (como Node Js, Python).\\n    - Balancedor de cargas: distribuye el trafico entre los servidores para evitar sobre cargas.\\n    - servidor de cache: guarda copias temporales para acelear las respuestas.\\n\\n### Instalaci\xf3n en Ubuntu \ud83d\udc68\u200d\ud83d\udcbb\\n\\n    En este caso realizaremos la instalaci\xf3n en Bubuntu, para que puedas realizar algunas pruebas tambien\\n    tendras el codigo disponible para que puedas utilizarlo en tu.\\n\\n        ``` bash title=\\" Bash\\"\\n        sudo apt update           #  actualizat linux\\n        sudo apt install nginx    #  instalar nginx\\n        ```\\n    una vez instalado podremos probar si Nginx esta corriendo adecuadamente usando\\n\\n        ``` bash title=\\" Bash\\"\\n        sudo systemctl status nginx\\n        ```\\n\\n    lo cual mostra algo asi si todo sale correctamente \ud83e\udd73\\n\\n        <img src=\\"/img/blog/nginx/nginx_status.png\\" alt=\\"contenedor\\" width=\\"800\\" />\\n\\n    de esta forma podremos saber si nuestro servido Nginx fue instalado de una forma correcta y esta funcionando\\n    desde este punto podremos las diferente carracteristicas de Nginx\\n\\n### Estructura de Nginx \ud83c\udfd7\ufe0f\\n\\nla estructura de Nginx es la siguiente que se genera automaticamente al instalar\\n\\n    ``` bash title=\\" Bash\\"\\n    /etc/nginx/\\n    \u251c\u2500\u2500 nginx.conf             # Configuraci\xf3n principal\\n    \u251c\u2500\u2500 sites-available/       # Configs de sitios disponibles\\n    \u251c\u2500\u2500 sites-enabled/         # Enlaces a sitios activos\\n    \u2514\u2500\u2500 conf.d/                #Configs adicionales (opcional)\\n    ```\\n\\n### Implemetando Nginx como servidor web \ud83d\udda5\ufe0f\\n\\nLa primera implementaci\xf3n que realizaremos es crear una pagina simple, sigue los pasos y podras crear\\ntu primer servidor web con Nginx en un servidor de linux.\\n\\n1. Crearemos una capeta en nuestro servidor \ud83d\udcc2\\n\\n        ``` bash title=\\" Bash\\"\\n        sudo mkdir -p /var/www/miweb\\n        ```\\n        - ```-p``` crea carpetas intermedias si no existen.\\n        - ```/var/www/``` es el lugar t\xedpico donde se alojan los sitios web.\\n\\n    este comando nos creara una carpeta en la ruta que le indicamos\\n\\n2. Es hora de crear nuestra super pagina \ud83d\udd28\\n    `bash title=\\" Bash\\"\\n    echo \\"<h1>Hola Bienvenidos a I am Devops </h1>\\" | sudo tee /var/www/miweb/index.html\\n   `\\n    Esto nos creara un archivo index.html con un mensaje.\\n    Puedes editarlo despu\xe9s con un editor como nano, vim o Visual Studio Code.\\n    en caso de que estes en un servidor de linux o uno de sus derivados es mas factible usar nano o vim\\n\\n3. Configuraci\xf3n de nuestro sitio \u2699\ufe0f\\n\\n    Nginx usa un archivo de configuraci\xf3n que nos permite saber c\xf3mo manejar los archivos\\n    ya que podemos tener alojado mas de una _web estatica_ dentro de nuestro servidor para crear nuestro achivo de confiraci\xf3n,\\n\\n         ``` bash title=\\" Bash\\"\\n         sudo nano /etc/nginx/sites-available/miweb\\n         ```\\n         ``` bash title=\\" site-avalible\\"\\n         server {\\n             listen 80;                       # Escucha en el puerto 80 (HTTP)\\n             server_name localhost;           # Nombre del servidor (puede ser dominio o IP)\\n\\n             root /var/www/miweb;             # Ruta al contenido del sitio\\n             index index.html;                # Archivo que se abre por defecto\\n\\n             location / {\\n                 try_files $uri $uri/ =404;   # Busca el archivo, si no existe, da error 404\\n             }\\n         }\\n         ```\\n\\n4. Habilitando nuestro sitio \ud83d\udd13\\n\\n    para poder habilitar nuestro sitio es necesrio vincular nueso `site-available/` a nuestro `site-enabled`\\n    para realizar ejecutaremos el siguiente comando para que se vincule\\n\\n    la ruta que debemos buscar si queremos encontrar estos archivos puede `/etc/nginx/sites-available/miweb` que es donde\\n    tendras a disponibles todos los archivos de nginx.\\n\\n    - **sites-available** : es el lugar donde estan configurados todos los sitios que se quieren habilitar.\\n    - **sites-enabled** : es donde le damos luz verde para poder salir.\\n\\n    en primer lugar iremos a `sites-available` y crearemos un archivo con el nombre de nuesto site\\n\\n       ```bash title=\\"Bash\\"\\n        vim /etc/nginx/sites-available/miweb\\n        ```\\n\\n    de esta forma crearemos un archivo de configuraci\xf3n para nuestra pagina en nuestro servidor de ubuntu\\n    este caso es para un servidor en local, en un futuro aprenderemos como hacer para que lo hagas en produci\xf3n\\n\\n        ```html title=\\"html\\"\\n            listen 80;\\n            listen [::]:80;\\n            root /var/www/miweb;\\n            server_name localhost;\\n            \\n            index index.html index.html;\\n\\n            location / {\\n                try_files $uri $uri/ =404;\\n            }\\n        }\\n        ```\\n\\n    una vez ya creado nuestro archivo estatico y nuestar configurac\xf3n, crearemos un simbolo de nuestro archivo en la\\n    carpeta `sites-enabled`\\n\\n        ```bash title=\\"Bash\\"\\n        sudo ln -s /etc/nginx/sites-available/miweb /etc/nginx/sites-enabled/\\n        ```\\n\\n5. validaci\xf3n de la configurac\xf3n \ud83e\udd73\\n   para este corrierndo corriendo el comando de test que trae nginx\\n\\n        ```bash title=\\"Bash\\"\\n        sudo nginx -t\\n        ```\\n    si todo esta corercto te saldra un mensaje parecido al siguiente\\n\\n        <img src=\\"/img/blog/nginx/nginx_config.png\\" alt=\\"contenedor\\" width=\\"600\\" />\\n\\n## Los errores \ud83d\ude05\\n\\n    Claramente todos cometemos errores y no estamos excentos de ello, por eso dejo este espacio\\n    ya que cometi algunos errores, donde me ha tocado inciar de 0.\\n\\n    Para eliminar totalmente nginx usamos lo siguiente\\n    ```bash title=\\"Bash\\"\\n    sudo apt remove --purge nginx nginx-common -y ---   # Eliminamos totalmente nginx\\n    sudo apt autoremove -y\\n    sudo rm -rf /etc/nginx /var/www/miweb               # Eliminamos los archivos creados\\n    ```\\n    de aqui solo queda volver a instalar *Ngnx* y volver a inciar nuestra configuraci\xf3n de cero.\\n\\n## Novemos en la 2 parte de este blog \ud83e\uddd0"},{"id":"manejo-del-repositorio","metadata":{"permalink":"/blog/manejo-del-repositorio","editUrl":"http://iamdevops.site/my_page/edit/main/blog/2025/repository_management/repository_management.md","source":"@site/blog/2025/repository_management/repository_management.md","title":"Manejo del repositorio","description":"Hola y bienvenidos a este blog, el cual est\xe1 orientado a entender como podemos manejar nuestros flujo","date":"2025-04-27T00:00:00.000Z","tags":[{"inline":false,"label":"Git","permalink":"/blog/tags/tags/git"},{"inline":false,"label":"Workflow","permalink":"/blog/tags/tags/workflow"},{"inline":false,"label":"Buenas Pr\xe1cticas","permalink":"/blog/tags/tags/buenas-practicas"}],"readingTime":2.63,"hasTruncateMarker":true,"authors":[{"name":"Alejandro Ram\xedrez","title":"Software Engineer | DevOps | Back-end Developer","url":"https://alejo95.github.io/my_page/about_me","description":"Alejandro Ram\xedrez is a back-end developer with a passion for creating efficient and scalable applications. He has a strong background in software development and is always eager to learn new technologies.\\n","social":{"linkedin":"https://www.linkedin.com/in/alejandro-ramirez-95/"},"imageURL":"https://avatars.githubusercontent.com/u/30883786?s=96&v=4","key":"alejandro-ramirez","page":null}],"frontMatter":{"slug":"manejo-del-repositorio","sidebar_position":0,"title":"Manejo del repositorio","tags":["git","workflow","buenas-practicas"],"authors":"alejandro-ramirez","date":"2025-04-27T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Nginx","permalink":"/blog/entendiendo_nginx"}},"content":"\x3c!-- truncate --\x3e\\n\\nHola y bienvenidos a este blog, el cual est\xe1 orientado a entender como podemos manejar nuestros flujo\\nde trabajo en git, haciendolo un poco mas claro y facil de entender en caso de tener algun problema\\nen **producci\xf3n** \ud83d\udca3 que es lo que no queremos que pase.\\n\\n## 1. Manejo de commits\\n\\nAl momento que generamos un commit es muy normal agregar el comentario sin una referencia las cuales nos\\nindiquen que estamos realizando en nuestro commit, para esto es recomendable usar banderas que nos permitan\\nentender que hicimos en nuestros commits para esto hacemos uso de las siguientes **Acciones** o **banderas**:\\n\\n- **[Acci\xf3n]**: identifica el tipo de commit\\n  - `feature` -  Se introduce una nueva caracter\xedstica con los cambios\\n  - `refactor` \u2013 C\xf3digo refactorizado que no corrige un error ni agrega una caracter\xedstica  \\n  - `docs` \u2013 Actualizaciones de la documentaci\xf3n, como el README u otros archivos de rebajas\\n  - `style` \u2013 Cambios que no afectan el significado del c\xf3digo, probablemente relacionados con el formato del c\xf3digo, como espacios en blanco, punto y coma faltantes, etc.\\n  - `test` \u2013 Incluyendo pruebas nuevas o corrigiendo pruebas anteriores\\n  - `perf` \u2013 Mejoras de rendimiento\\n  - `ci` \u2013 Relacionados con la integraci\xf3n continua\\n  - `build` \u2013 Cambios que afectan al sistema de compilaci\xf3n o dependencias externas\\n  - `revert` \u2013 revierte una confirmaci\xf3n anterior\\n\\n- **Cuerpo**: Entre 50 y 150 caracteres resaltando **\xbfqu\xe9?** y **\xbfpor qu\xe9?**.  \\n- **Idioma**: Ingl\xe9s.\\n\\n> **Ejemplo**  \\n> `[Added] validation so that the accounting information in the vendor once audited cannot be modified`  \\n> *(Comienza con may\xfascula y sin punto final.)*\\n\\n---\\n\\n## 1.2. Nomenclatura de ramas (branch)\\n\\nCon la nomenclatura la idea es siempre buscar identificar las ramas donde estamos trabajando y as\xed llevar\\nun flujo de versiones saludable, que sea f\xe1cil de entender, en este ejemplo usaremos una nomenclatura basada\\nen el flujo de trabajo de Git Flow.\\n\\nSiguiendo Git Flow te encontrar\xe1s con las siguientes ramas:\\n\\n- **master**: versiones estables en producci\xf3n (`vX.Y.Z`).  \\n- **develop**: integraci\xf3n de nuevas features.  \\n- **feature/***: desarrollo de caracter\xedsticas (desde `develop`).  \\n- **release/***: preparaci\xf3n de la pr\xf3xima versi\xf3n (desde `develop`).  \\n- **hotfix/***: correcciones urgentes (desde `master`).\\n\\n![Git Flow Diagram](/img/blog/Deploymentflow.png)\\n\\n---\\n\\n### Hoja de trucos (Comandos)\\n\\nEsta hoja de trucos tiene los **comandos** mas utilizados dentro del flujo de trabajo \ud83e\uddd1\ud83c\udffc\u200d\ud83d\udcbb, dentro de mi\\nconsideraci\xf3n son los que mas usaras durante tu carrera como programor o algunas de sus ramas.\\n\\naqui les dejo \ud83d\udc4c\\n\\n---\\n\\n| Operaci\xf3n                                    | Comando                                                |\\n|----------------------------------------------|--------------------------------------------------------|\\n| Clonar repositorio                           | `git clone ssh://usuario@dominio.com/repo.git`         |\\n| Crear repo local                             | `git init`                                             |\\n| Estado de archivos                           | `git status`                                           |\\n| Ver diferencias                              | `git diff`                                             |\\n| A\xf1adir todos los cambios                     | `git add .`                                            |\\n| Commit con mensaje                           | `git commit -m \\"Mensaje descriptivo\\"`                  |\\n| Modificar \xfaltimo commit                      | `git commit --amend`                                   |\\n\\n---\\n\\n## Ramas y etiquetas\\n\\n| Operaci\xf3n                        | Comando                        |\\n|----------------------------------|--------------------------------|\\n| Listar ramas                     | `git branch`                   |\\n| Crear nueva rama                 | `git branch <nombre>`          |\\n| Cambiar de rama                  | `git checkout <nombre>`        |\\n| Etiquetar versi\xf3n                | `git tag v1.2.3`               |\\n\\n---\\n\\n## Actualizar y publicar\\n\\n| Operaci\xf3n                      | Comando                              |\\n|--------------------------------|--------------------------------------|\\n| Descargar cambios sin merge    | `git fetch`                          |\\n| Descargar y merge              | `git pull origin <branch>`           |\\n| Enviar cambios a remoto        | `git push origin <branch>`           |\\n| Enviar etiquetas               | `git push --tags`                    |\\n\\n---\\n\\n## Fusionar y rebase\\n\\n| Operaci\xf3n                | Comando                           |\\n|--------------------------|-----------------------------------|\\n| Merge                    | `git merge <branch>`              |\\n| Rebase                   | `git rebase <branch>`             |\\n| Abortar rebase           | `git rebase --abort`              |\\n| Continuar rebase         | `git rebase --continue`           |\\n\\n---\\n\\n## Deshacer\\n\\n| Operaci\xf3n                              | Comando                                 |\\n|----------------------------------------|-----------------------------------------|\\n| Reset total (descarta todo)            | `git reset --hard HEAD`                 |\\n| Descartar cambios en un archivo        | `git checkout HEAD <file>`              |\\n| Revertir un commit                     | `git revert <commit>`                   |\\n| Reset suave (preserva cambios staged)  | `git reset <commit>`                    |\\n\\n---"}]}}')}}]);